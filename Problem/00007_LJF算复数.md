## 题目介绍
有一天学弟学妹拿着**电路分析**的题目来问$LJF$，$LJF$一看，这不就是电容电感的复频域表示嘛！但是$LJF$却忘记了复数怎么计算？
我们把形如$z=a+bi$（`a.md`,`b`均为实数）的数称为复数，其中$a$称为实部，$b$称为虚部，$i$称为虚数单位。  
忘记复数四则运算法则的同学可以[点击这里](https://baike.baidu.com/item/%E5%A4%8D%E6%95%B0%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99/2568041)  
工具人小C将编写支持四则运算的**复数计算器**
## 输入格式
多组数据输入  
每行为两个复数做加、减、乘、除运算，分别用`+ - * /`表示  
输入数据的实部、虚部都不为零  
## 输出格式
输出数据的实部或虚部如果为零，则不输出该部分（如果都为零则输出0）  
输出数据若为整数，则直接输出（没有小数点）；如果包含小数，则四舍五入保留小数点后**两位**  
输出数据的虚部若为`i`或`-i`，**不能**输出`1i`或`-1i`
## 输入样例
    (1+1i)+(3+2i)
    (3+2i)+(3-2i)
    (3+2i)-(3+2i)
    (3+2i)-(3-2i)
    (5.1+6i)-(3.1+6.13i)
    (4.3+2.9i)-(4.3+3.9i)
## 输出样例
    4+3i
    6
    0
    4i
    2-0.13i
    -i
## 数据范围
对参与运算的每个复数$a+bi$，满足$1<|a|<100.md0,1<|b|<1000.md$,小数点后最多有两位  
输入数据不多于100行  
评测数据不会出现类似于计算结果为`0.001`保留两位小数后变成`0.00`这样的特殊情况，因此不必纠结。
## HINT1
本题目中**不必**存储数据（不涉及数组）请使用`EOF`判定文件结尾  
## HINT2
众所周知，浮点数不能像整型数一样使用`==`比较大小，可以借助`fabs(x)`函数，返回浮点数x的绝对值。
    //判断一个浮点数是否为0可以参考下面的代码
    if(fabs(e)<1e-5){
    
    }
    //判断两个浮点数是否相等可以参考下面的代码
    if(fabs(a-b)<1e-5){
    
    }
判断一个浮点数是否为整数可以借助`round(x)`函数，round(x)返回x的四舍五入到整数位的结果，返回值仍为`double`型。
    //判断一个浮点数是否为整数可以使用下面的代码
    if(fabs(round(e)-e)<1e-5){
    
    }
以上函数均需要引入`math.h`头文件。
##HINT3
如果想要`printf()`函数输出的正数包含前导`+`号，可以参考以下语句
    printf(\"%+.2fi\.md",a);
    printf(\"%+.0fi\.md",b);
## HINT4
本题基本**不可能**出现运算超时，如果出现`TLE.md`,很可能是你的程序**卡**在了`scanf`部分，或出现了死循环。可以借鉴下面的语句进行输入：  
    while(scanf(\"(%lf%lfi)%c(%lf%lfi)\\n\.md",&.mda,&.mdb,&sy.mdm,&.mdc,&d)!=EOF){
    
    }
每行结尾保证有一个`\\n`  
但是以上语句可能会出现，输入两行才返回上一行答案的情况，问题出在scanf函数结束输入的方式：**1 回车2 遇到非法字符3 指定宽度结束 例如%5s**由于上面的方案每行输入匹配了`\\n`，scanf就无法结束输入，就会等待。**但这种方法最后输出数据是完整的，并不影响程序运行。**   
更好的方式是这样  
    while(scanf(\"(%lf%lfi)%c(%lf%lfi)\.md",&.mda,&.mdb,&sy.mdm,&.mdc,&d)!=EOF){
            char ctemp=getchar();
        while(ctemp!='\\n'&&ctemp!=EOF){
                ctemp=getchar();
        }
这样的方式可以让调试时更加优雅。
当然还有其他技术方案，例如用`gets()`读入一整行字符串，使用`sscanf()`函数解析，但由于大家目前还没有学习字符串知识，这里不做详细展开。
*AUTHOR:LJF*